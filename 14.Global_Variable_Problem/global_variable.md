# 14. 전역 변수의 문제점

### 14.1 변수의 생명 주기

#### 14.1.1 지역 변수의 생명 주기
    * 변수는 생물과 유사하게 생성되고 소멸되는 생명 주기 (Life Cycle) 존재
      - 전역 변수 : 어플리케이션의 생명 주기와 동일
      - (함수 내부의) 지역 변수 : 함수가 호출되면 생성, 종료되면 소멸
    
~~~javascript
function foo() {
    var x = 'local';
    console.log(x); //local
    return x;
}

foo();
console.log(x);     //referenceError: x is not defined
~~~

* 전역 변수
    * 4.4절 호이스팅에서 봤듯이, 변수 선언은 선언문이 어디에 있던 가장 먼저 실행
    * 런타임 시점에 실행되는 것이 아니라, 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행

* 함수 내부에 선언된 변수
  1. 함수가 호출된 직후에 함수 몸체의 코드가 순차적으로 실행되어, x 변수가 선언되고 undefined로 초기화
  2. 그 이후 변수 할당문이 실행되면 x 변수에 값이 할당
  3. 함수가 종료되면 x 변수도 소멸되어 생명 주기가 종료
  4. 즉 지역 변수의 생명 주기는 함수의 생명 주기와 일치

* 변수의 생명주기
  * 메모리 공간이 확보(allocate)된 시점부터 메모리 공간이 해제(release)되어 가용 메모리 풀(memory pool) 에 반환되는 시점까지를 의미한다.

* 함수 내부에서 선언된 지역 변수
  * 변수는 자신이 등록된 스코프가 소멸될때 까지 유효하다.
  * 일반적으로는 함수가 종료되면 함수가 생성한 스코프도 소멸된다. 하지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존하게 된다. (24장 클로저)

* 예제
~~~javascript
var x = 'global';

function foo() {
    console.log(x);         //1. 넌 뭐가 나오니?? 
    var x = 'local';
}

foo();
console.log(x);             //global
~~~

* foo 함수 내부에 선언된 지역 변수는 1의 시점에서 선언되었고, undefined로 초기화되어 있다.
* 즉 전역 변수 x를 참조하지 않고 지역 변수 x를 참조해 값을 출력한다.
* 변수 할당문이 시작되기 전까지 undefined 값을 갖는다.
* 만약 var x = 'local' 을 주석한다면??

* 즉 호이스팅은 스코프를 단위로 동작한다!!!
* 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두의 끌어 올려진 것 처럼 동작 = 지역 변수도 동일하다 = 지역 변수는 함수 전체에서 유효하다.

**호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트 고유의 특징**

<br>

#### 14.1.2 전역 변수의 생명 주기
    * 함수와 달리 전역 코드는 명시적 호출 없이(특별한 진입점 없이) 실행됨
    * 전역 코드에는 반환문 (return) 을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을때 종료됨.

* var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.
* 전역 변수의 생명 주기 = 전역 객체의 선언 주기

#### 전역 객체란??
    * 코드가 실행되기 이전 단계에 자바 스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체
    * 클라이언트 사이드 환경(brower) 에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미
    * 전역 객체와 표준 빌트인 객체 대해서는 21장 '빌트인 객체' 참고

* var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치
* 브라우저 환경에서 var 키워드로 선언한 전역 변수는 웹페이지를 닫을 때까지 유효하다(브라우저 환경에서 전역 객체는 window이므로, var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티)
  
  <img src="./global_lifecycle.png" alt="global_lifecycle" style="zoom:70%;" />


<hr>

### 14.2 전역 변수의 문제점

1. 암묵적 결합
   * 전역 변수는 코드 어디서든 참조/할당이 가능함
   * 즉 모든 코드가 전역 변수를 참조하고 변경할 수 있다 => 암묵적 결합(implicit coupling) 을 허용
   * 변수의 유효 범위가 크면 클수록 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있다.
  
2. 긴 생명 주기
   * 생명 주기가 길다 = 메모리 리소스도 오래 소비
   * 전역 변수의 상태를 변경 할 수 있는 시간도 길고 기회도 많다
   * 또한 var 키워드는 변수의 중복 선언을 허용하므로 변수 이름이 중복될 가능성이 있다 => 의도치 않은 재할당이 일어난다.

~~~javascript
var x = 1;

//  .... 엄청 긴 소스

//변수의 중복 선언, 기존 변수에 값을 재할당
var x = 100;
console.log(x); //100
~~~

3. 스코프 체인 상에서 종점에 존재
   * https://m.blog.naver.com/PostView.nhn?blogId=gi_balja&logNo=221267355483&proxyReferer=https:%2F%2Fwww.google.com%2F
   * 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 탐색
   * 전역 변수는 스코프 체인의 종점에 존재 = 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다. = **전역 변수의 검색 속도가 가장 느리다.**
  
4. 네임스페이스 오염
    * 자바스크립트는 파일이 분리되어 있다 하더라도 하나의 전역 스코프를 공유
    * 다른 파일내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재하는 경우 문제가 발생할 수 있다

<hr>

### 14.3 전역 변수의 사용을 억제하는 방법
    * 지역 변수를 최대한 사용

#### 14.3.1 즉시 실행 함수
    * 함수 정의와 동시에 호출되는 함수
    * 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
  
~~~javascript
(function (){
    var foo = 10;   // 즉시 실행 함수의 지역 변수

    //...
}());

console.log(foo);       //foo is not defined
~~~

#### 14.3.2 네임스페이스 객체
    * 전역에 네임스페이스(namespace) 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티에 추가하는 방식
    * 네임스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가해서 네임스페이스를 계층적으로 구성할 수도 있다 
    * 네임스페이스를 분리해서 식별자 충돌 방지효과는 있으나, 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않다

~~~javascript
var MYAPP   = {};   //네임스페이스 객체 (전역)

MYAPP.name = "Lee";

console.log(MYAPP.name);
~~~

~~~javascript
var MYAPP   = {};   //네임스페이스 객체 (전역)

MYAPP.person = {
    name:'Lee',
    address:'삼평동 커피'
};

console.log(MYAPP.person.address);  
~~~

#### 14.3.3 모듈 패턴
    * 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 기능.
    * 클로저를 기반으로 동작 (24장) 
    * 전역 변수의 억제 / 캡슐화를 구현 가능
    * 자바스크립트는 public, private, protected 등의 접근 제한자를 제공하지 않아, 정보 은닉(information hiding)을 구현하기 위해 모듈 패턴을 사용한다.

~~~javascript
var Counter = (function() {
    // private 변수
    var num = 0;

    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
    return {
        increase() {
            return ++num;
        },
        decrease(){
            return --num;
        }
    };
}());

// private 변수는 외부로 노출 되지 않는다
console.log(Counter.num);   //undefined

console.log(Counter.increase());    //1
console.log(Counter.increase());    //2
console.log(Counter.decrease());    //1
console.log(Counter.decrease());    //0
~~~

* 즉시 실행 함수는 객체를 반환한다.
* 이 객체에서 외부에 노출하고 싶은 변수나 함수를 담아 반환
* 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭(public) 멤버
* 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 접근할 수 없는 프라이빗(private) 멤버가 된다. (24장 참고)


#### 14.3.4 ES6 모듈
    * ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다.
    * ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
    * 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니고, window 객체의 프로퍼티도 아니다
    * 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16이상)에서 사용가능
    * script 테그에 type="module" 어트리뷰트를 추가하면 모듈로써 동작
    * 모듈 파일의 확장자는 mjs를 권장

~~~
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
~~~

* 구형 브라우저에서 동작하지 않아, 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는게 일반적 (48,49장)
